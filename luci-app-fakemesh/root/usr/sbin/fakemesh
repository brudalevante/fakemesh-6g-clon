#!/bin/sh

. /lib/functions.sh
. /lib/functions/network.sh

band_steer_helper=${band_steer_helper:-none}

# Function to get radio device for a specific band with robust detection
get_radio_for_band() {
	local band="$1"
	local radio=""
	
	# First try: direct band match in UCI
	radio=$(uci show wireless 2>/dev/null | grep ".band='${band}'" | head -n1 | cut -d. -f2)
	
	# If not found, try fallback detection based on common patterns
	if [ -z "$radio" ]; then
		case "$band" in
			"2g"|"2.4g")
				# Try common 2G radio names
				for r in radio0 phy0-ap0 wifi0; do
					if uci get wireless.$r >/dev/null 2>&1; then
						local hwmode=$(uci get wireless.$r.hwmode 2>/dev/null)
						local path=$(uci get wireless.$r.path 2>/dev/null)
						# Check if it's likely a 2G radio
						if [ "$hwmode" = "11g" ] || [ "$hwmode" = "11ng" ] || echo "$path" | grep -q "2g\|2\.4"; then
							radio="$r"
							break
						fi
					fi
				done
				;;
			"5g")
				# Try common 5G radio names  
				for r in radio1 phy1-ap0 wifi1; do
					if uci get wireless.$r >/dev/null 2>&1; then
						local hwmode=$(uci get wireless.$r.hwmode 2>/dev/null)
						local path=$(uci get wireless.$r.path 2>/dev/null)
						# Check if it's likely a 5G radio
						if [ "$hwmode" = "11a" ] || [ "$hwmode" = "11na" ] || echo "$path" | grep -q "5g\|5\."; then
							radio="$r"
							break
						fi
					fi
				done
				;;
			"6g")
				# Try common 6G radio names
				for r in radio2 phy2-ap0 wifi2; do
					if uci get wireless.$r >/dev/null 2>&1; then
						local hwmode=$(uci get wireless.$r.hwmode 2>/dev/null)
						local path=$(uci get wireless.$r.path 2>/dev/null)
						# Check if it's likely a 6G radio
						if echo "$hwmode" | grep -q "11ax\|11be" || echo "$path" | grep -q "6g\|6\."; then
							radio="$r"
							break
						fi
					fi
				done
				;;
		esac
	fi
	
	echo "$radio"
}

band_steer_helper_switch()
{
	if [ "$band_steer_helper" = "usteer" ]; then
		uci delete usteer.@usteer[0].event_log_types 2>/dev/null
		uci delete usteer.@usteer[0].ssid_list 2>/dev/null
		uci commit usteer
		test -x /etc/init.d/dawn && {
			/etc/init.d/dawn enabled && /etc/init.d/dawn disable
			/etc/init.d/dawn running && /etc/init.d/dawn stop
		}
		test -x /etc/init.d/usteer && {
			/etc/init.d/usteer enabled || /etc/init.d/usteer enable
			/etc/init.d/usteer running || /etc/init.d/usteer start
		}
	elif [ "$band_steer_helper" = "dawn" ]; then
		test -x /etc/init.d/usteer && {
			/etc/init.d/usteer enabled && /etc/init.d/usteer disable
			/etc/init.d/usteer running && /etc/init.d/usteer stop
		}
		test -x /etc/init.d/dawn && {
			/etc/init.d/dawn enabled || /etc/init.d/dawn enable
			/etc/init.d/dawn running || /etc/init.d/dawn start
		}
	else
		test -x /etc/init.d/dawn && {
			/etc/init.d/dawn enabled && /etc/init.d/dawn disable
			/etc/init.d/dawn running && /etc/init.d/dawn stop
		}
		test -x /etc/init.d/usteer && {
			/etc/init.d/usteer enabled && /etc/init.d/usteer disable
			/etc/init.d/usteer running && /etc/init.d/usteer stop
		}
	fi
}

[ "x$1" = "xband_steer_helper_switch" ] && {
	band_steer_helper_switch
	exit 0
}

[ "x$1" = "xsetup" ] && {
	exit 0
}

config_load fakemesh

config_get_bool enabled default 'enabled' '0'

# --- CORRECCIÓN: Al desactivar mesh, borra todas las interfaces meshx* correctamente ---
test $enabled -eq 0 && {
	rm -f /www/fakemesh.*
	rm -rf /tmp/fakemesh_lck*
	rm -f /tmp/fakemesh.firewall.include

	test -e /etc/init.d/umdns && {
		rm /tmp/fakemesh.umdns.json 2>/dev/null && \
		/etc/init.d/umdns restart
	}

	uci delete wireless.meshx0 &>/dev/null
	uci delete wireless.meshx1 &>/dev/null
	uci delete wireless.meshx2 &>/dev/null

	I=0
	while uci get wireless.@wifi-iface[$I] &>/dev/null; do
		echo "$(uci get wireless.@wifi-iface[$I].network)" | grep -q "^meshx" && {
			uci set wireless.@wifi-iface[$I].network="lan"
		}
		I=$((I+1))
	done

	uci delete fakemesh.default.wifim_md5 &>/dev/null
	uci delete dhcp.meshx0 &>/dev/null
	uci delete network.meshx0 &>/dev/null
	uci delete network.meshx0_6 &>/dev/null
	uci delete firewall.fakemesh &>/dev/null
	sed -i "/.* controller.fakemesh/d" /etc/hosts
	sed -i "/sh \/usr\/share\/fakemesh\/firewall.include.*/d" /etc/firewall.include

	#re-enable lan
	uci delete network.lan.auto &>/dev/null
	#re-enable wan
	uci delete network.wan.auto &>/dev/null
	uci delete network.wan6.auto &>/dev/null
	#del wan port from br-lan
	lan_idx=0
	while uci get network.@device[$lan_idx] &>/dev/null && [ $(uci get network.@device[$lan_idx].name) != "br-lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_ports="$(uci get network.@device[$lan_idx].ports 2>/dev/null)"
	wan_port="$(uci get network.wan.device 2>/dev/null)"
	newlan_ports=$(for lp in $lan_ports; do [ "$lp" = "$wan_port" ] || echo $lp; done | sort | uniq)
	newlan_ports=$(echo $newlan_ports)
	[ "$lan_ports" != "$newlan_ports" ] && {
		uci delete network.@device[$lan_idx].ports &>/dev/null
		for lp in $newlan_ports; do
			uci add_list network.@device[$lan_idx].ports="$lp"
		done
	}
	#delete meshx0 from lan zone
	lan_idx=0
	while uci get firewall.@zone[$lan_idx] &>/dev/null && [ $(uci get firewall.@zone[$lan_idx].name) != "lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_net="$(uci get firewall.@zone[$lan_idx].network 2>/dev/null)"
	newlan_net=$(for ln in $lan_net; do [ "$ln" = "meshx0" -o "$ln" = "meshx0_6" ] || echo $ln; done | sort | uniq)
	newlan_net=$(echo $newlan_net)
	[ "$lan_net" != "$newlan_net" ] && {
		uci delete firewall.@zone[$lan_idx].network &>/dev/null
		for ln in $newlan_net; do
			uci add_list firewall.@zone[$lan_idx].network="$ln"
		done
		uci commit firewall
	}

	uci changes

	uci commit fakemesh
	uci commit wireless
	uci commit dhcp
	uci commit firewall
	uci commit network
	/etc/init.d/network reload
	/etc/init.d/dnsmasq reload
	/etc/init.d/firewall reload &>/dev/null
	exit 0
}

config_get role default 'role' 'agent'
config_get band default 'band' '5g'
config_get Xid default 'id'
config_get Xkey default 'key'
config_get access_ip default 'access_ip' '10.10.10.1'
config_get sync_ac default 'sync_ac' '1'
config_get fronthaul_disabled default 'fronthaul_disabled' '0'

lost_ac=${lost_ac:-0}
LOST_AC_CNT=3

agent_lost_ac()
{
	[ "$role" = "agent" ] || [ "$role" = "wap" ] || return 0

	pid=$$
	logger -t fakemesh "agent_lost_ac($pid): started! lost_ac=$lost_ac"

	if test $lost_ac -gt $LOST_AC_CNT; then
		rm -rf /tmp/fakemesh_lck3
		lost_ac=$lost_ac exec /usr/sbin/fakemesh agent_sync_config &
		return 0
	fi

	#re-enable lan
	uci delete network.lan.auto &>/dev/null
	uci set network.lan.ipaddr="192.168.16.1"
	for lip in `seq 16 20`; do
		if ip route | grep -q "192.168.$lip.0/"; then
			:
		else
			uci set network.lan.ipaddr="192.168.$lip.1"
			break
		fi
	done
	uci set network.lan.netmask='255.255.255.0'
	logger -t fakemesh "agent_lost_ac($pid): setup temporary lan ip=$(uci get network.lan.ipaddr)"

	#re-enable lan enable wifi
	ssid="$(uci get base_config.@status[0].SSID)@$(uci get network.lan.ipaddr)"
	ssid_passwd=$(uci get base_config.@status[0].SSID_PASSWD)
	K=0
	for band in 2g 5g 6g; do
		radio=$(get_radio_for_band "$band")
		if test -n "$radio"; then
			uci set wireless.wifinet$K=wifi-iface
			uci set wireless.wifinet$K.device="${radio}"
			uci set wireless.wifinet$K.network='lan'
			uci set wireless.wifinet$K.mode='ap'
			uci set wireless.wifinet$K.ssid="${ssid}"
			uci set wireless.wifinet$K.encryption="sae"
			uci set wireless.wifinet$K.key="${ssid_passwd}"
			uci set wireless.wifinet$K.wpa_group_rekey='601'
			uci set wireless.wifinet$K.max_inactivity='301'
			if uci get wireless.${radio}.path | grep -q bcma || iwinfo wlan${radio:6} info | grep -qi Cypress; then
				WLAN_IDX=${radio:6}
				uci set wireless.wifinet$K.ifname="wlan${WLAN_IDX}"
			else
				uci set wireless.wifinet$K.ieee80211r='1'
				uci set wireless.wifinet$K.ft_over_ds='0'
				uci set wireless.wifinet$K.ft_psk_generate_local='1'
			fi

			uci delete wireless.wifinet$K.disabled 2>/dev/null
			K=$((K+1))
			logger -t fakemesh "agent_lost_ac($pid): starting wifi SSID=\'${ssid}\' on ${radio} $band!"
		fi
	done
	while uci get wireless.wifinet$K 2>/dev/null; do
		uci set wireless.wifinet$K.disabled='1'
		K=$((K+1))
	done

	nft_add_brmeshfilters() {
		brif="$1"
		nft add table netdev brmeshfilters_$brif 2>/dev/null
		nft "add chain netdev brmeshfilters_$brif devfilter { type filter hook ingress device $brif priority 0 ; }" 2>/dev/null
		nft add rule netdev brmeshfilters_$brif devfilter udp sport 68 drop 2>/dev/null
	}

	#drop all in-comming DHCP request from eth port
	for brif in $(cd /sys/class/net/br-lan/brif/ && ls); do
		iwinfo $brif info &>/dev/null && [ "$brif" != "meshx0" ] && [ "$brif" != "meshx1" ] && [ "$brif" != "meshx2" ] && continue
		nft_add_brmeshfilters $brif
	done

	#dhcp no push router for lan, no push dns for lan
	uci add_list dhcp.lan.dhcp_option='option:router'
	uci add_list dhcp.lan.dhcp_option='6'

	/etc/init.d/network reload
	/etc/init.d/dnsmasq reload
	sleep 5
	uci revert dhcp
	uci revert network
	uci revert wireless

	#drop all in-comming DHCP request from eth port
	#XXX: since network reload, netdevice may unregister and re-create, it is safe to re-add filter rules again.
	for brif in $(cd /sys/class/net/br-lan/brif/ && ls); do
		iwinfo $brif info &>/dev/null && [ "$brif" != "meshx0" ] && [ "$brif" != "meshx1" ]  && [ "$brif" != "meshx2" ] && continue
		nft_add_brmeshfilters $brif
	done

	logger -t fakemesh "agent_lost_ac($pid): done!"

	#make sure agent_sync_config stopped
	rm -rf /tmp/fakemesh_lck3
	lost_ac=$lost_ac exec /usr/sbin/fakemesh agent_sync_config &
}

agent_sync_config()
{
	[ "$sync_ac" = "1" ] || {
		return 0
	}
	[ "$role" = "wap" ] && {
		#make sure agent_keep_alive stopped
		rm -rf /tmp/fakemesh_lck2*
	}

	mkdir /tmp/fakemesh_lck3 || return 0
	pid=$$
	touch /tmp/fakemesh_lck3/$pid

	logger -t fakemesh "agent_sync_config($pid): started!"

	touch /tmp/fakemesh.ac.config
	ln -s /tmp/fakemesh.ac.config /etc/config/fakemeshac 2>/dev/null
	
	# Initialize fakemeshac config if empty (for UI display before first sync)
	if ! uci get fakemeshac.@wifim[0] &>/dev/null; then
		logger -t fakemesh "agent_sync_config($pid): initializing empty fakemeshac config for UI"
		# Convert band value to band list
		case "$band" in
		  2g5g6g) init_bands="2g 5g 6g" ;;
		  2g5g)   init_bands="2g 5g" ;;
		  5g6g)   init_bands="5g 6g" ;;
		  *)      init_bands="$band" ;;
		esac
		
		for b in $init_bands; do
			uci add fakemeshac wifim
			uci set fakemeshac.@wifim[-1].ssid="${Xid}-${b}"
			# Initialize with proper encryption instead of just "sae"
			if test -n "${Xkey}"; then
				uci set fakemeshac.@wifim[-1].encryption="sae"
				uci set fakemeshac.@wifim[-1].key="$Xkey"
			else
				uci set fakemeshac.@wifim[-1].encryption="none"
			fi
			uci set fakemeshac.@wifim[-1].band="$b"
			uci set fakemeshac.@wifim[-1].enabled="1"
		done
		uci commit fakemeshac
	fi

	while :; do
		[ "$role" != "controller" ] && {
			if test $lost_ac -gt 2; then
				ubus call network.interface.meshx0 down
				sleep 1
				ubus call network.interface.meshx0 up
				sleep 1
			fi
			ubus -t 15 wait_for network.interface.meshx0
		}
		sleep 15
		achost=controller.fakemesh
		if [ "$role" != "controller" ]; then
			if test $lost_ac -gt 0; then
				/etc/init.d/umdns reload
				sleep 5
			fi
			achost="$(ubus call umdns browse | jsonfilter -e "@['_fakemesh_${Xid}._tcp'][*]['ipv4']")"
			if ! test -n "$achost"; then
				logger -t fakemesh "agent_sync_config($pid): umdns: achost not found(lost_ac=$lost_ac)!"
				achost=controller.fakemesh
			fi
			acnum=$(echo -n "$achost" | wc -w)
			if [ "$acnum" -gt 1 ]; then
				logger -t fakemesh "agent_sync_config($pid): umdns: achost found $acnum($achost)(lost_ac=$lost_ac)!"
				rand=$(hexdump -e '"%u"' -n1 /dev/urandom)
				rand=$(((rand % acnum) + 1))
				achost=$(for w in $achost; do echo $w; done | head -n$rand | tail -n1)
				logger -t fakemesh "agent_sync_config($pid): umdns: achost found random select($achost)(lost_ac=$lost_ac)!"
			fi
		fi

		hash=$(echo -n ${Xid}${Xkey} | md5sum | head -c32)
		if ( \
		[ "$role" = "controller" ] && cp /etc/config/fakemesh /tmp/fakemesh.ac.config.tmp || \
		timeout 10 wget -4 -qO /tmp/fakemesh.ac.config.tmp http://$achost/fakemesh.$hash 2>/dev/null ); then
			:
		else
			lost_ac=$((lost_ac+1))
			logger -t fakemesh "agent_sync_config($pid): fetch config from $achost failed($lost_ac)!"
			acip=$(ip route | grep "default via" -m1 | awk '{print $3}')
			if test -n "$acip" && ifconfig br-lan | grep -q "addr:$acip "; then
				logger -t fakemesh "agent_sync_config($pid): acip=$acip is setup on br-lan(lost_ac=$lost_ac)!"
				ubus call network.interface.lan down
				/etc/init.d/network reload
				sleep 5
			fi
			if test -n "$acip" && [ "$role" != "controller" ] && timeout 5 wget -4 -qO /tmp/fakemesh.ac.config.tmp http://$acip/fakemesh.$hash 2>/dev/null; then
				logger -t fakemesh "agent_sync_config($pid): fetch config from gateway($acip) ok(lost_ac=$lost_ac)"
			elif test -n "$achost" && [ "$role" != "controller" ] && timeout 5 wget -4 -qO /tmp/fakemesh.ac.config.tmp http://$achost/fakemesh.$hash 2>/dev/null; then
				logger -t fakemesh "agent_sync_config($pid): fetch config from achost($achost) ok(lost_ac=$lost_ac)"
			else
				if test $lost_ac -ge $LOST_AC_CNT; then
					lost_ac=$lost_ac exec /usr/sbin/fakemesh agent_lost_ac &
					return 0
				fi
				logger -t fakemesh "agent_sync_config($pid): fetch config from achost($achost)/gateway($acip) failed($lost_ac), wait 30s"
				sleep 30
				rm -f /tmp/fakemesh.ac.config.tmp
				test -f /tmp/fakemesh_lck3/$pid || return 0
				continue
			fi
		fi

		if ! grep -q fakemesh /tmp/fakemesh.ac.config.tmp; then
			rm -f /tmp/fakemesh.ac.config.tmp
			test -f /tmp/fakemesh_lck3/$pid || return 0
			continue
		fi

		mv /tmp/fakemesh.ac.config.tmp /tmp/fakemesh.ac.config

		test $lost_ac -gt 0 && logger -t fakemesh "agent_sync_config($pid): fetch config ok!"

		oldbsh=$(uci get fakemesh.default.band_steer_helper || echo none)
		newbsh=$(uci get fakemeshac.default.band_steer_helper || echo none)
		[ "${oldbsh}" = "${newbsh}" ] || {
			uci set fakemesh.default.band_steer_helper="${newbsh}"
			uci commit fakemesh
			band_steer_helper="${newbsh}" exec /usr/sbin/fakemesh band_steer_helper_switch &
		}

		oldcfgmd5=$(uci get fakemesh.default.wifim_md5 2>/dev/null)
		newcfgmd5=$(uci show fakemeshac | grep "^fakemeshac.@wifim" | md5sum | head -c 32)
		[ "${oldcfgmd5}" = "${newcfgmd5}" ] || {
			logger -t fakemesh "agent_sync_config($pid): config change!"
			# --- CORRECCIÓN --- PRESERVAR TODAS LAS INTERFACES meshx* Y RECREAR REPETIDORES --- #
			I=0
			while uci get wireless.@wifi-iface[$I] &>/dev/null; do
				# Check if this interface is a mesh backhaul interface (STA mode) - preserve it
				if uci show wireless.@wifi-iface[$I] | grep -q 'mode.*sta' && uci show wireless.@wifi-iface[$I] | grep -q 'ifname.*meshx[012]'; then
					logger -t fakemesh "agent_sync_config($pid): preserving STA interface $I ($(uci get wireless.@wifi-iface[$I].ifname 2>/dev/null))"
					I=$((I+1))
					continue
				fi
				logger -t fakemesh "agent_sync_config($pid): removing interface $I for recreation"
				uci delete wireless.@wifi-iface[$I] &>/dev/null
			done

			J=0
			K=0

			while uci get fakemeshac.@wifim[$J] &>/dev/null; do
				ssid=$(uci get fakemeshac.@wifim[$J].ssid)
				encryption=$(uci get fakemeshac.@wifim[$J].encryption)
				key=$(uci get fakemeshac.@wifim[$J].key)
				bands=$(uci get fakemeshac.@wifim[$J].band)
				enabled=$(uci get fakemeshac.@wifim[$J].enabled || echo 1)

				[ "$bands" = "2g5g6g" ] && bands="2g 5g 6g"
				
				[ "$enabled" = "1" ] && {
					for band in $bands; do
						radio=$(get_radio_for_band "$band")
						if test -n "$radio"; then
							# For agents, create AP mode repeater interfaces
							uci set wireless.wifinet$K=wifi-iface
							uci set wireless.wifinet$K.device="${radio}"
							uci set wireless.wifinet$K.network='meshx0'
							uci set wireless.wifinet$K.mode='ap'
							uci set wireless.wifinet$K.ssid="${ssid}"
							uci set wireless.wifinet$K.wpa_group_rekey='601'
							uci set wireless.wifinet$K.max_inactivity='301'
							
							# Properly configure encryption
							if [ "${encryption}" != "none" ] && [ -n "${key}" ]; then
								uci set wireless.wifinet$K.encryption="${encryption}"
								uci set wireless.wifinet$K.key="${key}"
							else
								uci set wireless.wifinet$K.encryption='none'
							fi
							
							if uci get wireless.${radio}.path | grep -q bcma || iwinfo wlan${radio:5} info | grep -qi Cypress; then
								WLAN_IDX=${radio:5}
								uci set wireless.wifinet$K.ifname="wlan${WLAN_IDX}"
							else
								uci set wireless.wifinet$K.ieee80211r='1'
								uci set wireless.wifinet$K.ft_over_ds='1'
								uci set wireless.wifinet$K.ft_psk_generate_local='1'
							fi
							if opkg list-installed 2>/dev/null | grep -q wpad-basic || apk list 2>/dev/null | grep wpad-basic | grep -q installed; then
								:
							else
								uci set wireless.wifinet$K.bss_transition='1'
								uci set wireless.wifinet$K.wnm_sleep_mode='1'
								uci set wireless.wifinet$K.time_advertisement='2'
								uci set wireless.wifinet$K.time_zone='GMT0'
								uci set wireless.wifinet$K.ieee80211k='1'
								uci set wireless.wifinet$K.rrm_neighbor_report='1'
								uci set wireless.wifinet$K.rrm_beacon_report='1'
							fi

							K=$((K+1))
						fi
					done
				}

				J=$((J+1))
			done

			uci set fakemesh.default.wifim_md5="${newcfgmd5}"

			uci commit fakemesh
			uci commit wireless
			/etc/init.d/network reload &
		}

		test -f /tmp/fakemesh_lck3/$pid || return 0

		if test $lost_ac -ge $LOST_AC_CNT; then
			logger -t fakemesh "agent_sync_config($pid): recovery from lost_ac=$lost_ac!"
			sleep 5
			/etc/init.d/network reload
			/etc/init.d/dnsmasq reload
			nft list tables 2>/dev/null | grep 'table netdev brmeshfilters_' | while read tb; do
				nft delete $tb
			done
			test -x /etc/init.d/umdns && /etc/init.d/umdns reload
			test -x /etc/init.d/dawn && /etc/init.d/dawn restart
		fi
		lost_ac=0

		rand=$(hexdump -e '"%u"' -n1 /dev/urandom)
		sleep $((50+(rand+0)%20))
		test -f /tmp/fakemesh_lck3/$pid || return 0
	done

	rm -f /tmp/fakemesh_lck3/$pid; rmdir /tmp/fakemesh_lck3
}

agent_keep_alive()
{
	[ "$role" = "agent" ] || return 0

	sta_lost=0

	# Parse band to get primary band and STA interface for monitoring
	case "$band" in
	  2g5g6g|2g5g) primary_band="2g"; sta_iface="meshx0" ;;
	  5g6g) primary_band="5g"; sta_iface="meshx1" ;;
	  6g) primary_band="6g"; sta_iface="meshx2" ;;
	  5g) primary_band="5g"; sta_iface="meshx1" ;;
	  2g) primary_band="2g"; sta_iface="meshx0" ;;
	  *) primary_band="$band"; sta_iface="meshx1" ;;
	esac

	radio=$(get_radio_for_band "${primary_band}")
	if test -z "$radio"; then
		logger -t fakemesh "agent_keep_alive($pid): No radio found for band ${primary_band}!"
		return 1
	fi
	channel=$(uci get wireless.${radio}.channel)
	test -n "$channel" || return 1

	mkdir /tmp/fakemesh_lck2 || return 0
	pid=$$
	touch /tmp/fakemesh_lck2/$pid

	logger -t fakemesh "agent_keep_alive($pid): started!"
	while :; do
		sleep 10
		sta="$(ubus -S list wpa_supplicant.$sta_iface)"
		if test -n "$sta"; then
			if [ $(iwinfo $sta_iface info | grep -c 'ESSID: unknown') -ge 1 ]; then
				sta_lost=$((sta_lost+1))
				if [ "$sta_lost" -ge 3 ]; then
					logger -t fakemesh "agent_keep_alive($pid): Agent lost connection!"
					rm -f /tmp/fakemesh_lck2/$pid; rmdir /tmp/fakemesh_lck2
					exec /usr/sbin/fakemesh agent_fix_channel &
					return 0
				fi
			elif [ "$(iwinfo $sta_iface info | head -n3 | tail -n1 | awk '{print $4}')" != "$channel" ]; then
				logger -t fakemesh "agent_keep_alive($pid): Agent channel changed!"
				rm -f /tmp/fakemesh_lck2/$pid; rmdir /tmp/fakemesh_lck2
				exec /usr/sbin/fakemesh agent_fix_channel &
				return 0
			fi
		fi
		sleep 30
		test -f /tmp/fakemesh_lck2/$pid || return 0
	done

	rm -f /tmp/fakemesh_lck2/$pid; rmdir /tmp/fakemesh_lck2
}

agent_fix_channel()
{
	exec /usr/sbin/fakemesh agent_sync_config &

	[ "$role" = "agent" ] || return 0

	# Parse band to get primary band and STA interface for monitoring
	case "$band" in
	  2g5g6g|2g5g) primary_band="2g"; sta_iface="meshx0" ;;
	  5g6g) primary_band="5g"; sta_iface="meshx1" ;;
	  6g) primary_band="6g"; sta_iface="meshx2" ;;
	  5g) primary_band="5g"; sta_iface="meshx1" ;;
	  2g) primary_band="2g"; sta_iface="meshx0" ;;
	  *) primary_band="$band"; sta_iface="meshx1" ;;
	esac

	radio=$(get_radio_for_band "${primary_band}")
	if test -z "$radio"; then
		logger -t fakemesh "agent_fix_channel($pid): No radio found for band ${primary_band}!"
		return 1
	fi
	channel=$(uci get wireless.${radio}.channel)
	test -n "$channel" || return 1

	mkdir /tmp/fakemesh_lck1 || return 0
	pid=$$
	touch /tmp/fakemesh_lck1/$pid

	logger -t fakemesh "agent_fix_channel($pid): started!"
	while :; do
		sleep 10
		sta="$(ubus -S list wpa_supplicant.$sta_iface)"
		if test -n "$sta"; then
			chan=$(iwinfo $sta_iface scan | grep -A1 -B1 "ESSID: \"${Xid}\"" | head -n3 | tail -n1 | grep -io "Channel:.*"| awk '{print $2}')
			if test -n "$chan"; then
				if [ "$chan" != "$channel" ]; then
					logger -t fakemesh "agent_fix_channel($pid): Setting up channel ($chan) for ${radio}"
					uci set wireless.${radio}.channel="$chan"
					# --- Ajusta HTMODE según banda aquí ---
					if [ "$primary_band" = "5g" ]; then
						htmode=$(uci get wireless.${radio}.htmode 2>/dev/null)
						# EHT320 NO se debe usar en 5G, baja a EHT160 siempre
						if [ "$htmode" = "EHT320" ]; then
							uci set wireless.${radio}.htmode="EHT160"
						elif [ "$htmode" = "EHT160" ]; then
							# Solo canales bajos (usualmente 36-64) soportan 160 MHz
							if ! ([ "$chan" -ge 36 ] && [ "$chan" -le 64 ]); then
								uci set wireless.${radio}.htmode="EHT80"
							fi
						elif [ "$htmode" = "EHT80" ]; then
							if ! ([ "$chan" -ge 36 ] && [ "$chan" -le 128 ]); then
								uci set wireless.${radio}.htmode="EHT40"
							fi
						elif [ "$htmode" = "EHT40" ]; then
							if ! ([ "$chan" -ge 36 ] && [ "$chan" -le 144 ]); then
								uci set wireless.${radio}.htmode="EHT20"
							fi
						# Compatibilidad: VHT/HE
						elif [ "$htmode" = "VHT160" ] && ! ([ "$chan" -ge 36 ] && [ "$chan" -le 64 ]); then
							uci set wireless.${radio}.htmode="VHT80"
						elif [ "$htmode" = "HE160" ] && ! ([ "$chan" -ge 36 ] && [ "$chan" -le 64 ]); then
							uci set wireless.${radio}.htmode="HE80"
						fi
					elif [ "$primary_band" = "6g" ]; then
						htmode=$(uci get wireless.${radio}.htmode 2>/dev/null)
						case "$chan" in
							1|5|9|13|17|21|25|29|33|37)
								# EHT320, nada que hacer
								;;
							49|65|81|97|113|129|145|161|177|193|209|225)
								if [ "$htmode" = "EHT320" ]; then
									uci set wireless.${radio}.htmode="EHT160"
								fi
								;;
							65|73|81|89|97|105|113|121|129|137|145|153|161|169|177|185|193|201|209|217|225|233)
								if [ "$htmode" = "EHT320" ] || [ "$htmode" = "EHT160" ]; then
									uci set wireless.${radio}.htmode="EHT80"
								fi
								;;
							*)
								uci set wireless.${radio}.htmode="EHT20"
								;;
						esac
					fi
					uci commit wireless
					/etc/init.d/network reload &
				fi
				logger -t fakemesh "agent_fix_channel($pid): Channel ($chan) for ${radio} ready!"
				break
			fi
		fi
		sleep 20
		test -f /tmp/fakemesh_lck1/$pid || return 0
	done

	rm -f /tmp/fakemesh_lck1/$pid; rmdir /tmp/fakemesh_lck1

	exec /usr/sbin/fakemesh agent_keep_alive &
}
[ "x$1" = "xagent_lost_ac" ] && {
	agent_lost_ac
	exit 0
}

[ "x$1" = "xagent_fix_channel" ] && {
	agent_fix_channel
	exit 0
}

[ "x$1" = "xagent_keep_alive" ] && {
	agent_keep_alive
	exit 0
}

[ "x$1" = "xagent_sync_config" ] && {
	agent_sync_config
	exit 0
}

[ "x$1" = "xgen_config" ] && {
	# http://controller.fakemesh/fakemesh.435ca8a686ae9f07eb4eb67d2216b154
	[ "$role" = "controller" ] && {
		hash=$(echo -n ${Xid}${Xkey} | md5sum | head -c32)
		ln -s /etc/config/fakemesh /www/fakemesh.$hash 2>/dev/null
		for f in $(ls /www/fakemesh.*); do
			[ "$f" != "/www/fakemesh.$hash" ] && rm -f "$f"
		done
	}
	exit 0
}

test -n "${Xid}" || {
	exit 0
}

rm -rf /tmp/fakemesh_lck*

MACADDR=""
test -e /usr/share/natcapd/board_mac.lua && MACADDR=$(lua /usr/share/natcapd/board_mac.lua)
test -n "$MACADDR" || MACADDR=$(. /lib/functions/system.sh; get_mac_label | tr a-f A-F)
test -n "$MACADDR" || MACADDR=$(cat /etc/board.json | jsonfilter -e "$['network']['wan']['macaddr']" | tr a-f A-F)
test -n "$MACADDR" || MACADDR=$(cat /etc/board.json | jsonfilter -e "$['network']['lan']['macaddr']" | tr a-f A-F)
test -n "$MACADDR" || MACADDR=$(cat /sys/class/net/eth0/address | tr a-f A-F)
test -n "$MACADDR" || MACADDR=$(cat /sys/class/net/eth1/address | tr a-f A-F)
test -n "$MACADDR" || MACADDR=$(head -c6 /dev/urandom | hexdump -e '/1 "%02X:"' | head -c17)
test -n "$MACADDR" || MACADDR=$(head -c6 /dev/random | hexdump -e '/1 "%02X:"' | head -c17)

if [ "$role" = "controller" ]; then

	rm -rf /tmp/fakemesh_lck*

	test -e /etc/init.d/umdns && {
		mkdir -p /etc/umdns
		ln -s /tmp/fakemesh.umdns.json /etc/umdns 2>/dev/null
		umdns_json="{
	\"fakemesh\": {
		\"service\": \"_fakemesh_${Xid}._tcp.local\",
		\"port\": 65535,
		\"txt\": [ \"id=${Xid}\" ]
	}
}"
		[ "$(cat /tmp/fakemesh.umdns.json 2>/dev/null | md5sum | head -c32)" = "$(echo "$umdns_json" | md5sum | head -c32)" ] || {
			echo "$umdns_json" >/tmp/fakemesh.umdns.json
			/etc/init.d/umdns restart
		}
	}

	# --- NUEVO BLOQUE PARA SOPORTE DE BANDAS COMBINADAS ---
	# Convierte el valor de $band en una lista de bandas
	case "$band" in
	  2g5g6g) bands="2g 5g 6g" ;;
	  2g5g)   bands="2g 5g" ;;
	  5g6g)   bands="5g 6g" ;;
	  *)      bands="$band" ;;
	esac

	# Create mesh interfaces with consistent mapping: 2g->meshx0, 5g->meshx1, 6g->meshx2
	for b in $bands; do
		radio=$(get_radio_for_band "$b")
		if test -n "$radio"; then
			# Assign interface number based on band type for consistency
			case "$b" in
				"2g") mesh_iface="meshx0" ;;
				"5g") mesh_iface="meshx1" ;;
				"6g") mesh_iface="meshx2" ;;
				*) mesh_iface="meshx0" ;;  # fallback for unknown bands
			esac
			
			uci set wireless.$mesh_iface=wifi-iface
			uci set wireless.$mesh_iface.device="${radio}"
			uci set wireless.$mesh_iface.network='lan'
			uci set wireless.$mesh_iface.ifname="$mesh_iface"
			uci set wireless.$mesh_iface.mode='ap'
			uci set wireless.$mesh_iface.wds='1'
			uci set wireless.$mesh_iface.ssid="${Xid}"
			uci set wireless.$mesh_iface.hidden='0'
			uci set wireless.$mesh_iface.wpa_group_rekey='601'
			uci set wireless.$mesh_iface.max_inactivity='301'
			if test -n "${Xkey}"; then
				uci set wireless.$mesh_iface.encryption='sae'
				uci set wireless.$mesh_iface.key="${Xkey}"
			else
				uci set wireless.$mesh_iface.encryption='none'
			fi
			if [ "$fronthaul_disabled" = "1" ]; then
				uci set wireless.$mesh_iface.disabled='1'
			else
				uci delete wireless.$mesh_iface.disabled 2>/dev/null
			fi
			
# Configure 6G specific settings for meshx2
if [ "$b" = "6g" ] && [ "$mesh_iface" = "meshx2" ]; then
    # Force channel 37 if in auto or empty
    channel=$(uci get wireless.${radio}.channel 2>/dev/null || echo auto)
    if [ "$channel" = "auto" ] || [ -z "$channel" ]; then
        uci set wireless.${radio}.channel="37"
    fi

    # For multi-band configurations, keep 6G at EHT320 if available
    # Only adjust HTMODE for single 6G band selection
    num_bands=$(echo "$bands" | wc -w)
    if [ "$num_bands" -eq 1 ]; then
        # Single 6G band: adjust HTMODE for channel 37 compatibility
        htmode=$(uci get wireless.${radio}.htmode 2>/dev/null)
        case "$htmode" in
            EHT320|EHT160|EHT80)
                uci set wireless.${radio}.htmode='EHT40'
                ;;
        esac
    else
        # Multi-band configuration - keep 6G at EHT320 for best performance
        htmode=$(uci get wireless.${radio}.htmode 2>/dev/null)
        if [ -z "$htmode" ] || [ "$htmode" != "EHT320" ]; then
            uci set wireless.${radio}.htmode='EHT320'
        fi
    fi
fi
		fi
	done
	# --- FIN BLOQUE NUEVO ---

	uci delete dhcp.meshx0 &>/dev/null
	uci delete network.meshx0 &>/dev/null
	uci delete network.meshx0_6 &>/dev/null

	#re-enable lan
	uci delete network.lan.auto &>/dev/null
	#re-enable wan
	uci delete network.wan.auto &>/dev/null
	uci delete network.wan6.auto &>/dev/null
	#del wan port from br-lan
	lan_idx=0
	while uci get network.@device[$lan_idx] &>/dev/null && [ $(uci get network.@device[$lan_idx].name) != "br-lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_ports="$(uci get network.@device[$lan_idx].ports 2>/dev/null)"
	wan_port="$(uci get network.wan.device 2>/dev/null)"
	newlan_ports=$(for lp in $lan_ports; do [ "$lp" = "$wan_port" ] || echo $lp; done | sort | uniq)
	newlan_ports=$(echo $newlan_ports)
	[ "$lan_ports" != "$newlan_ports" ] && {
		uci delete network.@device[$lan_idx].ports &>/dev/null
		for lp in $newlan_ports; do
			uci add_list network.@device[$lan_idx].ports="$lp"
		done
	}
	
	#delete meshx0 from lan zone
	lan_idx=0
	while uci get firewall.@zone[$lan_idx] &>/dev/null && [ $(uci get firewall.@zone[$lan_idx].name) != "lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_net="$(uci get firewall.@zone[$lan_idx].network 2>/dev/null)"
	newlan_net=$(for ln in $lan_net; do [ "$ln" = "meshx0" -o "$ln" = "meshx0_6" ] || echo $ln; done | sort | uniq)
	newlan_net=$(echo $newlan_net)
	[ "$lan_net" != "$newlan_net" ] && {
		uci delete firewall.@zone[$lan_idx].network &>/dev/null
		for ln in $newlan_net; do
			uci add_list firewall.@zone[$lan_idx].network="$ln"
		done
		uci commit firewall
	}

	# === BLOQUE PARA CREAR LAS SECCIONES WIFIM EN FAKEMESHAC ===
	# Create demo wifim sections only for selected bands
	
	# Clear any existing wifim sections first
	while uci get fakemeshac.@wifim[0] &>/dev/null; do
		uci delete fakemeshac.@wifim[0]
	done

	# Create wifim sections only for selected bands
	for b in $bands; do
		ssid="${Xid}-${b}"
		encryption="sae"
		
		uci add fakemeshac wifim
		uci set fakemeshac.@wifim[-1].ssid="$ssid"
		uci set fakemeshac.@wifim[-1].encryption="$encryption"
		uci set fakemeshac.@wifim[-1].key="$Xkey"
		uci set fakemeshac.@wifim[-1].band="$b"
		uci set fakemeshac.@wifim[-1].enabled="1"
	done
	uci commit fakemeshac

# reload firewall
	uci delete firewall.fakemesh &>/dev/null && uci commit firewall

	mkdir -p /usr/share/fakemesh
	cat >/tmp/fakemesh.firewall.include <<-EOT
#!/bin/sh
iptables -t nat -C prerouting_lan_rule -d $access_ip/32 -p tcp --dport 80 -j REDIRECT --to-ports 80 2>/dev/null || \
iptables -t nat -A prerouting_lan_rule -d $access_ip/32 -p tcp --dport 80 -j REDIRECT --to-ports 80 2>/dev/null
iptables -t nat -C prerouting_lan_rule -d $access_ip/32 -p tcp --dport 443 -j REDIRECT --to-ports 443 2>/dev/null || \
iptables -t nat -A prerouting_lan_rule -d $access_ip/32 -p tcp --dport 443 -j REDIRECT --to-ports 443 2>/dev/null

nft -a list chain inet fw4 dstnat 2>/dev/null | grep -o "fakemesh.*" | while read _ _ _ handle; do nft delete rule inet fw4 dstnat handle \$handle; done
nft insert rule inet fw4 dstnat iifname { \$(echo \$(fw4 -q zone lan | grep -v '*' | sort | uniq | sed 's/\(.*\)/"\1",/g') | sed 's/,$//') } ip daddr $access_ip/32 tcp dport 80 counter redirect to :80 comment "fakemesh" 2>/dev/null
nft insert rule inet fw4 dstnat iifname { \$(echo \$(fw4 -q zone lan | grep -v '*' | sort | uniq | sed 's/\(.*\)/"\1",/g') | sed 's/,$//') } ip daddr $access_ip/32 tcp dport 443 counter redirect to :443 comment "fakemesh" 2>/dev/null

EOT
	ln -s /tmp/fakemesh.firewall.include /usr/share/fakemesh/firewall.include 2>/dev/null
	grep -q "^sh /usr/share/fakemesh/firewall.include" /etc/firewall.include || echo "sh /usr/share/fakemesh/firewall.include" >>/etc/firewall.include

	grep -q "^$access_ip controller.fakemesh ac.fakemesh" /etc/hosts || {
		if grep -q ".* controller.fakemesh ac.fakemesh" /etc/hosts; then
			sed -i "s/.* controller.fakemesh ac.fakemesh/$access_ip controller.fakemesh ac.fakemesh/" /etc/hosts
		else
			echo "$access_ip controller.fakemesh ac.fakemesh" >>/etc/hosts
		fi
		/etc/init.d/dnsmasq reload
	}

	/etc/init.d/firewall reload &>/dev/null

	exec /usr/sbin/fakemesh gen_config &

	uci changes

	test $(uci changes 2>/dev/null | grep -v "='dhcp'\|='interface'\|='wifi-iface'" | wc -l) -le 0 && {
		uci revert wireless
		uci revert dhcp
		uci revert network

		exec /usr/sbin/fakemesh agent_sync_config &
		exit 0
	}

	uci commit wireless
	uci commit dhcp
	uci commit network

	(sleep 15
	 /etc/init.d/network reload
	 /etc/init.d/dnsmasq reload
	 exec /usr/sbin/fakemesh agent_sync_config & )&
else
	rm -f /www/fakemesh.*
	/etc/init.d/sta_disable enabled 2>/dev/null && /etc/init.d/sta_disable disable

	test -e /etc/init.d/umdns && {
		rm /tmp/fakemesh.umdns.json 2>/dev/null && \
		/etc/init.d/umdns restart
	}

	# --- SUPPORT FOR MULTIPLE BANDS IN AGENT MODE ---
	# Convert band value to band list like controller does
	case "$band" in
	  2g5g6g) bands="2g 5g 6g" ;;
	  2g5g)   bands="2g 5g" ;;
	  5g6g)   bands="5g 6g" ;;
	  *)      bands="$band" ;;
	esac

	# Determine primary band for STA interface (backhaul connection)
	case "$band" in
	  2g5g6g|2g5g) primary_band="2g" ;;
	  5g6g) primary_band="5g" ;;
	  6g) primary_band="6g" ;;
	  5g) primary_band="5g" ;;
	  2g) primary_band="2g" ;;
	  *) primary_band="$band" ;;
	esac

	# Create mesh interfaces (AP mode) with consistent mapping: 2g->meshx0, 5g->meshx1, 6g->meshx2
	# BUT exclude the primary band from mesh interface creation to avoid conflicts with STA
	for b in $bands; do
		# Skip primary band for mesh interface creation - it will be used for STA
		[ "$b" = "$primary_band" ] && continue
		
		radio=$(get_radio_for_band "$b")
		if test -n "$radio"; then
			# Assign interface number based on band type for consistency with controller
			case "$b" in
				"2g") mesh_iface="meshx0" ;;
				"5g") mesh_iface="meshx1" ;;
				"6g") mesh_iface="meshx2" ;;
				*) mesh_iface="meshx0" ;;  # fallback for unknown bands
			esac
			
			logger -t fakemesh "agent: creating mesh interface $mesh_iface for band $b on radio $radio"
			
			# Create mesh interface for non-primary bands (AP mode for repeating)
			uci set wireless.$mesh_iface=wifi-iface
			uci set wireless.$mesh_iface.device="${radio}"
			uci set wireless.$mesh_iface.network='meshx0'
			uci set wireless.$mesh_iface.ifname="$mesh_iface"
			uci set wireless.$mesh_iface.mode='ap'
			uci set wireless.$mesh_iface.wds='1'
			uci set wireless.$mesh_iface.ssid="${Xid}"
			uci set wireless.$mesh_iface.hidden='0'
			uci set wireless.$mesh_iface.wpa_group_rekey='601'
			uci set wireless.$mesh_iface.max_inactivity='301'
			if test -n "${Xkey}"; then
				uci set wireless.$mesh_iface.encryption='sae'
				uci set wireless.$mesh_iface.key="${Xkey}"
			else
				uci set wireless.$mesh_iface.encryption='none'
			fi
			if [ "$fronthaul_disabled" = "1" ]; then
				uci set wireless.$mesh_iface.disabled='1'
			else
				uci delete wireless.$mesh_iface.disabled 2>/dev/null
			fi
			
			# Configure 6G specific settings
			if [ "$b" = "6g" ]; then
				channel=$(uci get wireless.${radio}.channel 2>/dev/null || echo auto)
				if [ "$channel" = "auto" ] || [ -z "$channel" ]; then
					uci set wireless.${radio}.channel='37'
				fi
				# Preserve EHT320 for 6G
				htmode=$(uci get wireless.${radio}.htmode 2>/dev/null)
				if [ -z "$htmode" ]; then
					uci set wireless.${radio}.htmode='EHT320'
				fi
			fi
		fi
	done

	# Create STA interface for primary band connection to controller (backhaul)
	primary_radio=$(get_radio_for_band "${primary_band}")
	if test -n "$primary_radio"; then
		# Assign STA interface name based on primary band
		case "$primary_band" in
			"2g") sta_iface="meshx0" ;;
			"5g") sta_iface="meshx1" ;;
			"6g") sta_iface="meshx2" ;;
			*) sta_iface="meshx1" ;;  # fallback
		esac
		
		logger -t fakemesh "agent: creating STA interface $sta_iface for primary band $primary_band on radio $primary_radio"
		
		# Create STA interface for backhaul client on primary band
		uci set wireless.$sta_iface=wifi-iface
		uci set wireless.$sta_iface.device="${primary_radio}"
		uci set wireless.$sta_iface.network='meshx0'
		uci set wireless.$sta_iface.ifname="$sta_iface"
		uci set wireless.$sta_iface.mode='sta'
		uci set wireless.$sta_iface.wds='1'
		uci set wireless.$sta_iface.ssid="${Xid}"
		if test -n "${Xkey}"; then
			uci set wireless.$sta_iface.encryption='sae'
			uci set wireless.$sta_iface.key="${Xkey}"
		else
			uci set wireless.$sta_iface.encryption='none'
		fi
		if [ "$role" = "wap" ]; then
			uci set wireless.$sta_iface.disabled='1'
		else
			uci delete wireless.$sta_iface.disabled 2>/dev/null
		fi
		
		# Configure 6G specific settings for STA
		if [ "$primary_band" = "6g" ]; then
			channel=$(uci get wireless.${primary_radio}.channel 2>/dev/null || echo auto)
			if [ "$channel" = "auto" ] || [ -z "$channel" ]; then
				uci set wireless.${primary_radio}.channel='37'
			fi
			# Preserve EHT320 for 6G
			htmode=$(uci get wireless.${primary_radio}.htmode 2>/dev/null)
			if [ -z "$htmode" ]; then
				uci set wireless.${primary_radio}.htmode='EHT320'
			fi
		fi
	fi

	uci set dhcp.meshx0=dhcp
	uci set dhcp.meshx0.ignore='1'

	uci set network.lan.auto='0'

	uci set network.meshx0=interface
	uci set network.meshx0.device="$(uci get network.lan.device)"
	uci set network.meshx0.proto='dhcp'
	uci set network.meshx0.defaultroute='1'
	uci set network.meshx0.metric='10'
	uci set network.meshx0.hostname="MESH-AGENT_$(echo -n $MACADDR | sed 's/://g' | tr a-f A-F)"

	uci set network.meshx0_6=interface
	uci set network.meshx0_6.proto='dhcpv6'
	uci set network.meshx0_6.device='@meshx0'
	uci set network.meshx0_6.reqaddress='try'
	uci set network.meshx0_6.reqprefix='auto'
	uci set network.meshx0_6.delegate='0'
	uci set network.meshx0_6.hostname="MESH-AGENT_$(echo -n $MACADDR | sed 's/://g' | tr a-f A-F)"

	#add meshx0 to lan zone
	lan_idx=0
	while uci get firewall.@zone[$lan_idx] &>/dev/null && [ $(uci get firewall.@zone[$lan_idx].name) != "lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_net="$(uci get firewall.@zone[$lan_idx].network 2>/dev/null)"
	newlan_net=$(for ln in $lan_net meshx0 meshx0_6; do echo $ln; done | sort | uniq)
	newlan_net=$(echo $newlan_net)
	[ "$lan_net" != "$newlan_net" ] && {
		uci delete firewall.@zone[$lan_idx].network &>/dev/null
		for ln in $newlan_net; do
			uci add_list firewall.@zone[$lan_idx].network="$ln"
		done
		uci commit firewall
	}

	#disable wan
	uci set network.wan.auto='0' 2>/dev/null
	uci set network.wan6.auto='0' 2>/dev/null
	#add wan port to br-lan
	lan_idx=0
	while uci get network.@device[$lan_idx] &>/dev/null && [ $(uci get network.@device[$lan_idx].name) != "br-lan" ]; do lan_idx=$((lan_idx+1)); done
	lan_ports="$(uci get network.@device[$lan_idx].ports 2>/dev/null)"
	wan_port="$(uci get network.wan.device 2>/dev/null)"
	newlan_ports=$(for lp in $lan_ports $wan_port; do echo $lp; done | sort | uniq)
	newlan_ports=$(echo $newlan_ports)
	[ "$lan_ports" != "$newlan_ports" ] && {
		uci delete network.@device[$lan_idx].ports &>/dev/null
		for lp in $newlan_ports; do
			uci add_list network.@device[$lan_idx].ports="$lp"
		done
	}

	# reload firewall
	uci delete firewall.fakemesh &>/dev/null && uci commit firewall

	mkdir -p /usr/share/fakemesh
	cat >/tmp/fakemesh.firewall.include <<-EOT
#!/bin/sh
iptables -t filter -C output_lan_rule -j MARK --set-xmark 0x00010000/0x00010000 2>/dev/null || \
iptables -t filter -A output_lan_rule -j MARK --set-xmark 0x00010000/0x00010000 2>/dev/null
iptables -t nat -C zone_lan_postrouting -m mark --mark 0x00010000/0x00010000 -j MASQUERADE 2>/dev/null || \
iptables -t nat -A zone_lan_postrouting -m mark --mark 0x00010000/0x00010000 -j MASQUERADE 2>/dev/null

nft -a list chain inet fw4 output_lan 2>/dev/null | grep -o "fakemesh_mark_0x10000.*" | while read _ _ _ handle; do nft delete rule inet fw4 output_lan handle \$handle; done
nft insert rule inet fw4 output_lan counter meta mark set mark or 0x10000 comment "fakemesh_mark_0x10000" 2>/dev/null

nft -a list chain inet fw4 srcnat 2>/dev/null | grep -o "fakemesh_mark_0x10000.*" | while read _ _ _ handle; do nft delete rule inet fw4 srcnat handle \$handle; done
nft insert rule inet fw4 srcnat oifname { \$(echo \$(fw4 -q zone lan | grep -v '*' | sort | uniq | sed 's/\(.*\)/\"\1\",/g') | sed 's/,$//') } mark and 0x10000 == 0x10000 counter masquerade comment "fakemesh_mark_0x10000" 2>/dev/null
EOT
	ln -s /tmp/fakemesh.firewall.include /usr/share/fakemesh/firewall.include 2>/dev/null
	grep -q "^sh /usr/share/fakemesh/firewall.include" /etc/firewall.include || echo "sh /usr/share/fakemesh/firewall.include" >>/etc/firewall.include

	/etc/init.d/firewall reload &>/dev/null

	uci changes

	test $(uci changes 2>/dev/null | grep -v "='dhcp'\|='interface'\|='wifi-iface'" | wc -l) -le 0 && {
		uci revert wireless
		uci revert dhcp
		uci revert network

		exec /usr/sbin/fakemesh agent_fix_channel &
		exit 0
	}

	uci commit wireless
	uci commit dhcp
	uci commit network
	sed -i "/.* controller.fakemesh/d" /etc/hosts

	(sleep 15
	 /etc/init.d/network reload
	 /etc/init.d/dnsmasq reload
	 exec /usr/sbin/fakemesh agent_fix_channel & )&
fi 
